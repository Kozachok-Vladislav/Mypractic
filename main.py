#1.	Создайте функцию, которая удалит буквы «a», «b» и «c» из данной строки и вернёт изменённую версию.
# Если данная строка не содержит «a», «b» или «c», вернуть null.

def remove_abc(string):
    # Удаление символов 'a', 'b' и 'c' из строки
    new_string = string.replace('a', '').replace('b', '').replace('c', '')

    # Если полученная строка не пуста, вернуть ее
    if new_string:
        return new_string
    # Иначе, вернуть None
    else:
        return None

#В этой функции мы удаляем символы 'a', 'b' и 'c' из входной строки с помощью функции replace().
# Затем мы проверяем, пуста ли полученная строка. Если она не пуста, мы возвращаем ее.
# Иначе, мы возвращаем None.


#2.	Напишите функцию, которая возвращает позицию второго вхождения "zip" в строку или -1,
# если оно не встречается как минимум дважды. Ваш код должен быть достаточно общим,
# чтобы передавать все возможные случаи, когда "zip" может встречаться в строке.

def second_occurrence(string):
  first_occurrence = string.find("zip")
  second_occurrence = string.find("zip", first_occurrence + 1)
  if second_occurrence == -1:
    return -1
  else:
    return second_occurrence

#Мы можем решить эту задачу, используя метод find в Python.
# Метод find возвращает индекс первого вхождения указанной подстроки в строке или -1,
# если подстрока не найдена. Мы можем использовать этот метод дважды для поиска двух вхождений "zip" в строке.
#В этой функции мы сначала ищем первое вхождение "zip" в строке с помощью метода find,
# а затем ищем второе вхождение, используя метод find со вторым аргументом,
# указывающим начальный индекс для поиска. Если второе вхождение не найдено, функция вернет -1,
# иначе вернет позицию второго вхождения "zip" в строке.


#3.	Изограмма - это слово, в котором нет повторяющихся букв.
# Создайте функцию, которая принимает строку и возвращает true или false в зависимости от того,
# является ли она «изограммой».

def is_isogram(string):
    return len(string) == len(set(string.lower()))

#Функция is_isogram принимает аргумент string, который представляет собой строку.
# Она вычисляет длину строки и количество уникальных символов в строке, преобразованных в нижний регистр,
# используя set. Если длина строки равна количеству уникальных символов,
# функция возвращает True, иначе False.


def is_isograme(s):
    return s == s[::-1]


#Эта функция принимает строку s в качестве аргумента и возвращает True или False
# в зависимости от того, является ли строка изограммой или нет.
#Для этого мы сравниваем строку с ее обратным порядком, используя слайс s[::-1].


#4.Создайте функцию, которая принимает массив целых чисел,
# отдельно суммирует чётные и нечётные числа, а затем возвращает разницу
# между суммой четных и нечётных чисел.


def diff_sum_even_odd(numbers):
    # Суммируем четные числа
    sum_even = sum([num for num in numbers if num % 2 == 0])
    # Суммируем нечетные числа
    sum_odd = sum([num for num in numbers if num % 2 != 0])
    # Вычисляем разницу между суммой четных и нечетных чисел
    return sum_even - sum_odd

#В этой функции мы сначала используем встроенную функцию sum()
# для суммирования четных чисел в массиве, которые мы выбираем с помощью
# генератора списков [num for num in numbers if num % 2 == 0].
#Затем мы суммируем нечетные числа в массиве тем же способом.
#Наконец, мы вычисляем разницу между суммой четных и нечетных чисел и возвращаем результат.

#5.	Напишите функцию, которая принимает массив и возвращает
# новый массив с неуникальными отрицательными числами.


def get_negative_non_unique(numbers):
    negative_numbers = []
    for num in numbers:
        if num < 0 and numbers.count(num) > 1:
            negative_numbers.append(num)
    return negative_numbers

#Эта функция принимает массив numbers как входной параметр. Затем создается
# пустой список negative_numbers для хранения отрицательных неуникальных чисел.
# Далее, функция использует цикл for для перебора каждого числа в numbers.
# Для каждого числа, функция проверяет, является ли число отрицательным и есть ли еще другие элементы
# с тем же значением, используя метод count(). Если условие соблюдено,
# число добавляется в negative_numbers. Наконец, функция возвращает список negative_numbers.

def negative_non_unique(arr):
    return [i for i in arr if i < 0 and arr.count(i) > 1]

#Эта функция использует списочные выражения, чтобы создать новый массив,
# состоящий из элементов, удовлетворяющих условию:
# меньше нуля и количество в исходном массиве больше 1.
# Это означает, что мы выбираем только отрицательные числа,
# которые встречаются в исходном массиве более одного раза.
# Затем этот новый массив возвращается как результат функции.


#6.По заданному массиву чисел, представляющих высоту горы в определенных интервалах,
# определите, является ли эта гора масштабируемой. Гору можно считать масштабируемой,
# если каждое число находится в пределах 5 единиц от следующего числа в любом направлении.

#Мы можем решить эту задачу, используя цикл for для перебора элементов массива
# и сравнивания каждого элемента со следующим элементом, используя условный оператор if.
# Если разница между числами превышает 5, то мы возвращаем False,
# иначе мы продолжаем перебирать элементы массива.

def is_mountain_scalable(heights):
    for i in range(1, len(heights)):
        if abs(heights[i] - heights[i - 1]) > 5:
            return False
    return True

#for i in range(1, len(heights)): цикл идет по всем элементам массива, кроме первого.
#abs(heights[i] - heights[i-1]): вычисляет абсолютную разницу между текущим элементом и предыдущим элементом.
#if abs(heights[i] - heights[i-1]) > 5: return False: если разница больше 5,
# значит гора не является масштабируемой и функция возвращает False.
#return True: если цикл закончился, значит гора является масштабируемой и функция возвращает True.


#7.	Создайте функцию, которая принимает на вход число n и возвращает все числа до n включительно,
# соединённые в строку. Каждую цифру отделяйте друг от друга знаком «-».

def number_to_string(n):
    return '-'.join(map(str, range(1, n + 1)))

#Эта функция использует функцию range для создания списка чисел от 1 до n.
# Затем этот список преобразуется в список строк с помощью функции map,
# которая применяет функцию str к каждому элементу списка.
# Наконец, этот список строк соединяется в одну строку с помощью функции join
# и возвращается как результат.


#8.	Создайте функцию, которая принимает массив чисел arr и число n.
# Верните true, если сумма любых двух элементов равна заданному числу.
# В противном случае верните false.

#Мы можем решить эту задачу, используя два цикла, чтобы проверить каждую пару чисел в массиве.
# В цикле внутри цикла мы сравним сумму каждой пары чисел с заданным числом. Если сумма равна числу,
# вернем true, в противном случае вернем false после выхода из внутреннего цикла.

def has_pair_with_sum(arr, n):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == n:
                return True
    return False


#Вышеуказанный код решает задачу, но его сложность O(n^2), что может быть медленным для больших массивов.
# Однако, если мы используем хеш-таблицу, мы можем улучшить сложность до O(n) и ускорить решение.


#9.	Создайте функцию, которая возвращает общее количество шагов,
# необходимых для преобразования каждого элемента в максимальный элемент в массиве.
# Каждый шаг состоит из увеличения цифры на единицу.

#Мы можем решить эту задачу, создав функцию, которая принимает массив целых чисел и возвращает
# общее количество шагов, необходимых для преобразования каждого элемента
# в максимальный элемент в массиве. Вы можете это сделать, используя цикл for
# и вычисление разницы между максимальным элементом и каждым элементом массива.


def steps_to_convert(arr):
    max_element = max(arr)
    steps = 0
    for i in arr:
        steps += max_element - i
    return steps



#В качестве аргумента функция принимает список чисел arr.
#С помощью функции находим максимальный элемент в списке max()и сохраняем его в max_element переменной.
#Затем мы инициализируем переменную steps для отслеживания общего количества шагов.
#Затем мы перебираем каждый элемент i в списке arr и вычисляем количество шагов.
# i вычитанием max_element i из max_element и добавление steps.
#Наконец, функция возвращает steps.


#10.Определите наименьшее количество шагов, необходимых для преобразования строки
# полностью в верхний регистр или полностью в нижний регистр, в зависимости от того,
# что занимает наименьшее количество шагов.
# Шаг состоит из изменения одного символа с нижнего на верхний регистр или наоборот.

#Мы можем решить эту задачу, используя простые алгоритмы счета.Мы можем создать функцию,
# которая считает количество символов, находящихся в верхнем и нижнем регистрах,
# и выбирает то, которое требует меньшего количества изменений.

def steps_to_convert(s):
    upper_count = 0
    lower_count = 0
    for c in s:
        if c.isupper():
            upper_count += 1
        else:
            lower_count += 1
    return min(upper_count, lower_count)

#Функция принимает входную строку s и инициализирует две переменные upper_count и lower_count,
# чтобы отслеживать количество символов в верхнем и нижнем регистрах соответственно.
# Затем цикл for идет через каждый символ в строке s, используя функцию isupper() для проверки,
# является ли символ в верхнем регистре. Если да, upper_count увеличивается на 1,
# иначе lower_count увеличивается на 1. Наконец, функция возвращает минимум из upper_count


#11.Напишите функцию, которая возвращает самую длинную последовательность
# в двоичной строке.

def longest_sequence_of_zeros(binary_string):
    current_sequence = 0
    longest_sequence = 0

    for character in binary_string:
        if character == "0":
            current_sequence += 1
        else:
            if current_sequence > longest_sequence:
                longest_sequence = current_sequence
            current_sequence = 0

    return longest_sequence

#В этой функции мы используем два переменные: current_sequence и longest_sequence.
# current_sequence используется для отслеживания текущей последовательности нулей,
# а longest_sequence для отслеживания самой длинной последовательности.

#Мы итерируемся по каждому символу в binary_string, и если этот символ является "0",
# мы увеличиваем current_sequence на 1. Если этот символ не является "0", мы сравниваем
# current_sequence с longest_sequence и, если он больше, мы запоминаем новый longest_sequence.
# Затем мы сбрасываем current_sequence в 0.
#Наконец, мы возвращаем longest_sequence в качестве результата функции.



#12.Представьте себе устройство для обмена сообщениями с одной кнопкой.
# Для буквы A вы нажимаете кнопку один раз, для буквы E вы нажимаете ее пять раз,
# для буквы G она нажимается семь раз, и т.д. Напишите функцию,
# которая принимает строку (сообщение) и возвращает общее количество раз, сколько кнопка нажата.

#Мы можем написать функцию, которая будет считать количество раз, сколько кнопка нажата,
# используя словарь, в котором будут храниться значения для каждой буквы, и итерироваться по строке,
# чтобы подсчитать количество раз, сколько кнопка нажата для каждой буквы.

def button_press_count(message):
    button_press_values = {
        'a': 1, 'b': 2, 'c': 3, 'd': 4,
        'e': 5, 'f': 6, 'g': 7, 'h': 8,
        'i': 9, 'j': 10, 'k': 11, 'l': 12,
        'm': 13, 'n': 14, 'o': 15, 'p': 16,
        'q': 17, 'r': 18, 's': 19, 't': 20,
        'u': 21, 'v': 22, 'w': 23, 'x': 24,
        'y': 25, 'z': 26
    }
    total_count = 0
    message = message.lower()
    for char in message:
        if char in button_press_values:
            total_count += button_press_values[char]
    return total_count

"""print(button_press_count("HELLO")) # Output: 35"""


def button_presses(message):
    press_count = 0
    button_presses = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 4]
    for char in message:
        press_count += button_presses[ord(char.upper()) - 65]
    return press_count

#В этой функции сначала создается список button_presses, который
# хранит количество нажатий для каждой буквы алфавита (A-Z).
# Затем цикл for перебирает каждый символ в строке message.
# Для каждого символа мы используем функцию ord для получения кода ASCII символа,
# затем вычитаем 65, чтобы получить индекс в списке button_presses.
# Количество нажатий для этой буквы добавляется к общему количеству нажатий press_count.
# В конце функция возвращает press_count.


#13.Создайте функцию, которая принимает символы строки как ASCII и возвращает
# шестнадцатеричное значение каждого символа как строку.

#Мы можем использовать функцию hex в Python, чтобы преобразовать число в шестнадцатеричную строку.
# Вот пример функции, которая принимает строку и возвращает
# шестнадцатеричные значения ASCII для каждого символа:

def ascii_to_hex(string):
    hex_values = []
    for char in string:
        hex_value = hex(ord(char))
        hex_values.append(hex_value)
    return hex_values

#ord(char) функция возвращает ASCII значение символа.
#hex(ord(char)) возвращает шестнадцатеричное представление этого числа.
#Мы добавляем каждое шестнадцатеричное представление в список hex_values и возвращаем его в конце функции.


#14.Создайте функцию, которая принимает целое число и выводит квадрат размером n x n,
# состоящий исключительно из целого числа n.

def print_square(n):
    for i in range(n):
        """print(str(n) * n)"""


#Эта функция принимает целое число n и выводит квадрат размером n x n,
# состоящий исключительно из целого числа n.
#Функция использует цикл for для печати n строк, где каждая строка является строкой,
# состоящей исключительно из целого числа n, умноженного на n.
# Функция str используется для преобразования целого числа n в строку.


#15.Предположим, что для каждого слоя ткани, который вы носите,
# когда на улице холодно (пальто, кардиганы, и т. д.),
# температура увеличивается на одну десятую от общей.
# Учитывая количество слоёв и заданную температуру,
# определите температуру внутри всех этих слоёв.
# Округлите ответ до ближайшей десятой градуса.

#Для решения этой задачи мы можем создать функцию, которая принимает
# число слоев и заданную температуру, и вычисляет и возвращает
# увеличенную температуру внутри всех этих слоев. Для округления до
# ближайшей десятой градуса мы можем использовать функцию round() в Python.


def temperature(layers, temperature):
  # Увеличение температуры на одну десятую от общей для каждого слоя
  temperature = temperature + (0.1 * layers)
  # Округление температуры до ближайшей десятой
  temperature = round(temperature, 1)
  return temperature

"""print(temperature(3, 15)) # 15.3"""

#В этом примере функция temperature() принимает два параметра: layers - число слоев и
# temperature - заданную температуру. Внутри функции мы увеличиваем
# температуру на одну десятую для каждого слоя, а затем округляем результат
# до ближайшей десятой. Наконец, мы возвращаем увеличенную температуру.

#Для решения этой задачи мы можем создать функцию,
# которая принимает количество слоёв и заданную температуру, и вычисляет увеличенную температуру.

def temperature_increase(layers, temperature):
    return round(temperature + (temperature * (layers * 0.1)), 1)

#ayers - количество слоёв ткани.
#temperature - заданная температура.
#Функция вычисляет увеличенную температуру, умножая заданную температуру
# на сумму 1 и результата умножения layers на 0,1
# (отображающий на какое количество увеличивается температура за каждый слой).
#Функция round используется для округления увеличенной температуры до ближайшей десятой градуса.



















